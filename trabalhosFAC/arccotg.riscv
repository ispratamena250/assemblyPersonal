#Method: if       x > 1  --> 1/x - 1/3*x^3 + 1/5*x^5 - 1/7*x^7 + ... 		  --> CASE 0
#	 if   0 < x <= 1 --> 3.141592/2 - (x - x^3/3 + x^5/5 - x^7/7 + ...) 	  --> CASE 1
#	 if       x = 0  --> 3.141592/2 					  --> CASE 2
#	 if -1 <= x < 0  --> 3.141592/2 - (x - x^3/3 + x^5/5 - x^7/7 + ...)       --> CASE 3
# 	 if       x < -1 --> 3.141592 + (1/x - 1/3*x^3 + 1/5*x^5 - 1/7*x^7 + ...) --> CASE 4
#Hint: after an underline (_) there is a hint of the "type" of an object; 's' for strings, 'v' for vectors, etc.
.globl main
.data
	pi_n: .float 3.141592
	suc_s: .asciz "success"
	nl_s: .asciz "\n"
.text
main:
	#init
	la a2, pi_n
	flw f0, 0(a2)
	li t0, 1
	fcvt.s.wu f1, t0 #f1 = 1.0
	li t1, -1
	fcvt.s.w f2, t1 #f2 = -1.0
	li t3, 3 #loop
	li t4, 0
	li t5, 1 #pow

	#exemple
#	fmv.s fa0, f0
#	li a7, 2
#	ecall #print pi_n into fa0
#	la a0, nl_s
#	li a7, 4
#	ecall #print nl_s into a0

	#read
	li a7, 6
	ecall #read float from console and write in fa0
	fmv.s f3, fa0 #save input
	
	flt.s t2, f1, fa0 #t2 = 1 if f1 < fa0
	beq t2, t0, case0 #branch if t1 != t0 that is if x > 1
	
	j end
	
	case0: 
		fc0:
		bge t4, t3, out_fc0
			
			li t6, 1
			pow:
				bge t6, t5, out_pow
				fmul.s f3, f3, f3 #f3 = pow(f3)
				fsw f4, 0(f3)
				addi t6, t6, 1
				j pow
			out_pow:
		
		addi t4, t4, 1
		addi t5, t5, 2
		j fc0
		
		out_fc0:
		
		j end
		
	end:
		la a0, nl_s
		li a7, 4
		ecall #print nl_s into a0
		
		li a7, 10
		ecall #end