#Hint: already commented instructions won't be recommented.
#Hint: after an underline (_) there is a hint of the "type" of an object; 's' for strings, 'l' for labels, etc.
.globl main_l
.data 
	xs_v: .word 64, 32, 16, 8, 4, 2, 1
	ans_v: .word 0, 0, 0, 0, 0, 0, 0, 0
	ie128_s: .asciz "entrada incorreta"
	bitParidade_s: .asciz "bit-paridade: "
	saida_s: .asciz "saida: "
	nl_s: .asciz "\n"
.text
main_l:
	#standard input
	li a7, 5 
	ecall #read a int from console and load it into a0
	mv t4, a0 #save input into t4
	
	#exception: if input is 0
	beq a0, 0, ie0_l
	
	#exception: if input is 128
	beq a0, 128, ie128_l
	
	#init
	la t0, xs_v #t0 = xs_v[0]
	la t1, zero #index for xs_v[]
	li t2, 7 #xs_v[] size
	la t3, ans_v #index for ans_v[]
	la a2, zero #sum of elements in xs_v[]
	
	#converting from base 10 into 2
	jal ra, base10into2_l #jump to label and link next pc state into ra
	
	#@3
	
	#convert decimal into binary
	base10into2_l:
		bge t1, t2, done1_l #branch if t1 >= t2
		
		lw a0, 0(t0) #a0 = xs_v[t0]
		
		addi t3, t3, 4 #one word for ans_v[]
			
		blt a0, 0(t0), small_l
		small_l:
			blt a2, t4, small2_l:
			small2_l:
				add a2, a2, a0
		
				#slt a3, a2, t4 #(a2 < t4) ? a3 = 1 : a3 = 0
				lw a3, 1
		
				sw a3, 0(t3)
		
				lw a3, zero
		
				addi t0, t0, 4 #one word for xs_v[]
		
				addi t1, t1, 1 #t1++
				done3_l:
		done2_l:
		
			beq a2, t4, done_l
		
			blt a2, t4, base10into2_l 
		
			done1_l:
				ret #return to pc state saved in ra
		
	#convert binary into decimal
	base2into10_l:
		#@2

	#if input equals to 0, print 0 and exit
	ie0_l:
		la a0, bitParidade_s
		li a7, 4
		ecall #print null terminated string in a0
	
		li a0, 0
		li a7, 1
		ecall #print int in a0
		
		j end_l

	#if input equals to 128, exit
	ie128_l:
		la a0, ie128_s
		li a7, 4
		ecall #print null terminated string in a0
		
		j end_l

	end_l:
		la a0, nl_s
		li a7, 4
		ecall  #print null terminated string in a0
		
		li a7, 10
		ecall #exit with
