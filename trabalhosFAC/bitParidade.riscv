#Hint: already commented instructions won't be recommented.
#Hint: after an underline (_) there is a hint of the "type" of an object; 's' for strings, 'l' for labels, etc.
.globl main_l
.data 
	xs_v: .word 64, 32, 16, 8, 4, 2, 1
	ans_v: .word 0, 0, 0, 0, 0, 0, 0, 0
	ie128_s: .asciz "entrada incorreta"
	bitParidade_s: .asciz "bit-paridade: "
	saida_s: .asciz "saida: "
	space_s: .asciz " "
	nl_s: .asciz "\n"
.text
main_l:
	#standard input
	li a7, 5 
	ecall #read a int from console and load it into a0
	mv t4, a0 #save input into t4
	
	#exception: if input is 0
	li t0, 0
	beq a0, t0, ie0_l
	
	#exception: if input is 128
	li t1, 128
	beq a0, t1, ie128_l
	
	#init
	la t0, xs_v #t0 = xs_v[0]
	li t1, 0 #index for xs_v[]
	li t2, 7 #xs_v[] size
	la t3, ans_v #index for ans_v[]
	li a2, 0 #sum of elements in xs_v[]
	
	#converting from base 10 into 2
	jal ra, base10into2_l #jump to label and link next pc state into ra
	
	#teste
	la t5, ans_v
	li t1, 0
	li t2, 8
	li t6, 0
	for:
		bge t1, t2, end_l
		lw a0, 0(t5)
		li a7, 1
		ecall 
		#la a0, space_s
		#li a7, 4
		#ecall 
		addi t5, t5, 4
		addi t1, t1, 1
		j for
	
	#@3
	
	#convert decimal into binary
	base10into2_l:
		bge t1, t2, done1_l
	
		lw a0, 0(t0)
		
		addi t3, t3, 4
		
		blt a0, t4, greater_l
	
		blt t4, a0, small_l
		
		blt a2, t4, base10into2_l
		
		greater_l:
			add a2, a2, a0
		
			li a3, 1
			
			sw a3, 0(t3)
		
			addi t0, t0, 4
			
			addi t1, t1, 1
		
			j base10into2_l
		
		small_l:
			addi t0, t0, 4
			
			addi t1, t1, 1
			
			j base10into2_l
		
		done1_l:
			ret
		
	#convert binary into decimal
	#base2into10_l:
		#@2

	#if input equals to 0, print 0 and exit
	ie0_l:
		la a0, bitParidade_s
		li a7, 4
		ecall #print null terminated string in a0
	
		li a0, 0
		li a7, 1
		ecall #print int in a0
		
		j end_l

	#if input equals to 128, exit
	ie128_l:
		la a0, ie128_s
		li a7, 4
		ecall #print null terminated string in a0
		
		j end_l

	end_l:
		la a0, nl_s
		li a7, 4
		ecall  #print null terminated string in a0
		
		li a7, 10
		ecall #exit with
