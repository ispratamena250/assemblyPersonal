#Hint: already commented instructions won't be recommented.
#Hint: after an underline (_) there is a hint of the "type" of an object; 's' for strings, 'l' for labels, etc.
.globl main_l
.data 
	xs_v: .word 64, 32, 16, 8, 4, 2, 1
	ys_v: .word 128, 64, 32, 16, 8, 4, 2, 1
	ans_v: .word 0, 0, 0, 0, 0, 0, 0, 0
	ie128_s: .asciz "entrada incorreta"
	bitParidade_s: .asciz "bit-paridade: "
	saida_s: .asciz "saida: "
	nl_s: .asciz "\n"
.text
main_l:
	#standard input
	li a7, 5 
	ecall #read a int from console and load it into a0
	mv t4, a0 #save input into t4
	
	#exception: if input is 0
	li t0, 0
	beq a0, t0, ie0_l
	
	#exception: if input is 128
	li t1, 128
	beq a0, t1, ie128_l
	
	#init
	la t0, xs_v #t0 = xs_v[0]
	li t1, 0 #index for xs_v[]
	li t2, 7 #xs_v[] size
	la t3, ans_v #index for ans_v[]
	li a2, 0 #sum of elements in xs_v[]
	li a5, 0 #bit-paridade
	
	#converting from base 10 into 2
	jal ra, base10into2_l #jump to label and link next pc state into ra
	
	la a0, bitParidade_s
	li a7, 4
	ecall 
	jal ra, whichParidade_l
	#
	mv a0, a5
	li a7, 1
	ecall
	#
	la a0, nl_s
	li a7, 4
	ecall
	
	#converting from base 2 into 10
	jal ra, base2into10_l
	
	la a0, saida_s
	li a7, 4
	ecall 
	mv a0, a4 #printa saida aqui
	li a7, 1
	ecall
	
	#test
	la a0, nl_s
	li a7, 4 
	ecall
	jal ra, test_l
	
	j end_l
	
	#convert decimal into binary
	base10into2_l:
		    bge t1, t2, done1_l #index i      
		
		    lw a0, 0(t0) #a0 = xs_v[t0]               
		    addi t3, t3, 4 #position in ans_v[t3]           
		
		    blt t4, a0, writeZero_l #if current value is less then the element in ans_v[t3]
		
		    sub t4, t4, a0
		    addi a5, a5, 1 #bit-paridade
		    li a3, 1
		    sw a3, 0(t3) #right 1 in ans_v[t3]
		    addi t0, t0, 4 #position in xs_v[t0]
		    addi t1, t1, 1
		    
		    j base10into2_l
		
		writeZero_l:
		    sw x0, 0(t3) #right 0 in ans_v[t3]               
		    addi t0, t0, 4
		    addi t1, t1, 1
		    
		    j base10into2_l
		
		done1_l:
		    ret
		
	#convert binary into decimal
	base2into10_l:
		la t0, ans_v
		li t1, 0
		li t2, 8
		li t3, 1
		la t4, ys_v
		li a4, 0 #saida
		
		beq a5, t3, bitParidadeEquals1_l
		
		beq a5, zero, bitParidadeEquals0_l
		
		bitParidadeEquals1_l:
			sw t3, 0(t0)
			
			j for1_l
			
		bitParidadeEquals0_l:
			li t3, 0
			
			sw t3, 0(t0)
			
			j for1_l
		
		for1_l:
			bge t1, t2, done2_l
			
			lw a0, 0(t0)
			lw t5, 0(t4)
						
			beq a0, x0, skipWhenZero_l

			add a4, a4, t5
			
			skipWhenZero_l:
				addi t0, t0, 4
				
				addi t4, t4, 4
				
				addi t1, t1, 1
			
				j for1_l
				
		done2_l:
			ret

	#finding paridade
	whichParidade_l:
		li t1, 2
	
		remu a0, a5, t1
		
		beq a0, zero, equalsZero_l
		
		li a5, 1
		
		j outWhichParidade_l
		
		equalsZero_l:
			li a5, 0
			
			j outWhichParidade_l
		
		outWhichParidade_l:
			ret

	#if input equals to 0, print 0 and exit
	ie0_l:
		la a0, bitParidade_s
		li a7, 4
		ecall #print null terminated string in a0
	
		li a0, 0
		li a7, 1
		ecall #print int in a0
		
		la a0, nl_s
		li a7, 4
		ecall
		
		la a0, saida_s
		li a7, 4
		ecall
		
		li a0, 0
		li a7, 1
		ecall
		
		j end_l

	#if input equals to 128, exit
	ie128_l:
		la a0, ie128_s
		li a7, 4
		ecall #print null terminated string in a0
		
		j end_l

	end_l:
		la a0, nl_s
		li a7, 4
		ecall  #print null terminated string in a0
		
		li a7, 10
		ecall #exit with 0
		
	#test: print ans_v[]
	test_l:
		la t5, ans_v
		li t1, 0
		li t2, 8
		li t6, 0
		forTest_l:
			bge t1, t2, outTest_l
			lw a0, 0(t5)
			li a7, 1
			ecall  
			addi t5, t5, 4
			addi t1, t1, 1
			j forTest_l
		outTest_l:
			ret